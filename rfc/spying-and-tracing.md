# Spying and Tracing

This feature adds the ability to expose the inner workings of MobX. It will report over console logs or DDT about the various activities happening inside MobX. This includes:

- When observables are read and written
- When actions are invoked
- When reactions are triggered

## Benefits

MobX so far has been somewhat of a black-box, nicely hiding all the details of how its reactive system works internally. Some users have seen this as "too much magic" and not sure of how/why things work. The problem exacerbates when you have runtime exceptions. The amount of detail exposed on the error may not be enough. It also lacks the complete trace of events that led to the failure.

Spying/Tracing will expose all these details and make it clear as to what is happening inside MobX. To generalize, we feel this feature would do the following:

- Give better visibility of MobX internals
- Enable better developer experience while debugging

## Implementation Strategy

Changes will be required in `mobx` and `mobx_codegen` packages. We are modeling the strategy around the way its done in [**mobx.js**](https://github.com/mobxjs/mobx/search?q=spyReport&unscoped_q=spyReport).

### `mobx` changes

- Create the `spy(listener, {context})` function that will attach a spy. The return value is a function that can dispose the spy. Spies are context specific and by default will use the `mainContext` to tap into all the reactivity. By providing a custom context, spies will only monitor the observables, actions and reactions happening in that context.

```dart

typedef Dispose = void Function();
typedef SpyListener = void Function(SpyEvent event);

Dispose spy(SpyListener listener, {ReactiveContext context = mainContext});

```

```dart
enum SpyEventType {
  observable, action, reaction
}

class SpyEvent {
  SpyEvent(this.type, this.object, {this.name, this.isStart, this.isEnd});

  final dynamic object;
  final SpyEventType type;
  final String name;

  final bool isStart;
  final bool isEnd;
}

```

- A `spyReport(event)` function is needed to report a specific activity
- Some activities like actions / reactions, are transactional and have a distinct begin-end semantics. For those we will need a `spyReportStart(event)` and `spyReportEnd(event)` functions.
- The current state of spying can be checked with `isSpyEnabled()`. This is context specific.

```dart
bool isSpyEnabled({ReactiveContext context = mainContext});
```

### When to report?

- For an observable, `spyReport()` is called on creation. `spyReportStart()` is called before setting the value and `spyReportEnd()` after.
- For a computed, a simple `spyReport()` is enough before the new value is set
- For a reaction, `spyReportStart()` is called before running the reaction and `spyReportEnd()` after the reaction completes.

### Side notes

- There are `Atom`s used internally for `Observable{List,Map,Set}` that will have to be explicitly reported to `spy`.
- `ObservableFuture` and `ObservableStream` needs to have special spy reporting

### `mobx_codegen` changes

The setters generated by `mobx_codegen` do not use an observable. Instead, they rely on `Atoms` to do the reporting. This means the `spyReport***` calls will not be made unless specifically injected with the codegen. The `spyReport{Start,End}` calls will be made before and after the setting of the value.
